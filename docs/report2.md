# Задание 2 (Неделя 2). ERD, 3НФ, БД, импорт, отчеты, backup, доступ

## 1) ER-диаграмма и 3НФ

### 1.1. Сущности
- `user_role` — роли пользователей (Менеджер/Оператор/Специалист/Заказчик).
- `app_user` — пользователи системы.
- `request_status` — статусы заявки (в т.ч. признак финальности `is_final`).
- `equipment_type` — тип оборудования.
- `equipment_model` — модель оборудования (привязана к типу).
- `issue_type` — тип неисправности (справочник для отчетности/статистики).
- `repair_request` — заявка на ремонт.
- `request_comment` — комментарии специалистов по заявкам.

### 1.2. Нормализация до 3НФ (что сделано)
- Повторяющиеся значения вынесены в справочники:
  - типы оборудования → `equipment_type`
  - модели оборудования → `equipment_model` (уникальность по паре тип+модель)
  - типы неисправностей → `issue_type`
  - статусы → `request_status`
  - роли → `user_role`
- Таблица `repair_request` хранит только ссылки на справочники (FK) и атрибуты самой заявки.
- Таблица `request_comment` хранит только атрибуты комментария + ссылки на заявку и автора.

### 1.3. ERD
- Mermaid ERD: `docs/er_diagram.mmd`.
- Для сдачи можно экспортировать ERD в PDF из DBeaver/pgAdmin:
  - DBeaver: Database → ER Diagram → Export/Print
  - pgAdmin: ERD Tool (если доступен)

## 2) Обеспечение ссылочной целостности и ограничений
Реализовано в `db/init.sql`:
- Первичные ключи (PK) во всех таблицах.
- Внешние ключи (FK) на связи:
  - `repair_request -> equipment_model, issue_type, request_status, app_user`
  - `equipment_model -> equipment_type`
  - `request_comment -> repair_request, app_user`
- Уникальности:
  - `equipment_type.name`, `issue_type.name`, `request_status.name`, `user_role.name`, `app_user.login`
  - `equipment_model(equipment_type_id, name)`
- Проверки данных:
  - `completion_date IS NULL OR completion_date >= start_date`

Дополнительно добавлены триггеры:
- Запрет назначать `client_id` не из роли "Заказчик".
- Запрет назначать `master_id` не из роли "Специалист".
- Автозаполнение `completion_date`, если статус финальный и дата не указана.

## 3) Создание БД и таблиц
В Docker это происходит автоматически:
- PostgreSQL выполняет `db/init.sql` при первом старте контейнера.

## 4) Импорт данных заказчика
Файлы CSV лежат в `data/import/`.
Импорт выполняет контейнер `importer`:
- `scripts/import_data.py`
- Порядок импорта:
  1) роли, статусы
  2) типы оборудования
  3) типы неисправностей
  4) модели оборудования
  5) пользователи
  6) заявки
  7) комментарии

## 5) Запросы и отчеты
SQL-отчеты сохранены в `db/reports.sql`, в том числе:
- список заявок с деталями
- выполненные заявки по типам оборудования
- среднее время ремонта по типам оборудования
- топ типов неисправностей
- нагрузка специалистов по активным заявкам

## 6) Резервное копирование БД
Скрипты:
- Linux/macOS: `scripts/backup_db.sh`
- Windows PowerShell: `scripts/backup_db.ps1`

Результаты сохраняются в `backups/` в формате `pg_dump -F c`.

## 7) Принцип регистрации пользователей
Выбран принцип: **централизованное создание учетных записей**.
- Учетные записи создаются администратором/менеджером (в учебном проекте — импортом).
- Саморегистрация отключена.
Причина: роли влияют на доступ к заявкам и требуют назначения ответственных лиц.

## 8) Группы пользователей и уровни доступа
В проекте реализовано **RBAC**:
- Уровни доступа задаются ролью пользователя (`user_role`) и проверяются в приложении:
  - Менеджер: просмотр всех заявок, пользователей, статистики.
  - Оператор: создание/редактирование/удаление заявок, назначение специалистов.
  - Специалист: видит только свои заявки, может комментировать свои заявки.
  - Заказчик: видит только свои заявки, может править свою заявку до финального статуса.

Дополнительно (демонстрация на уровне СУБД):
- `db/security.sql` создает роли PostgreSQL `svc_*` и назначает права на таблицы.